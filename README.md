# Huffman
Huffman Encoding

This is a project containing three different .java files: Node.java, huffmanEncoding.java and main.java.

The goal of the project is to generate a random string and encode then decode it utilizing huffman encoding. This is achieved by first looping through the randomly generated string and counting how many times each character appears, building a hashmap to store this information. Then each element in the hashmap is made into a node and stored into an array. Using the already made nodes the tree is built with less common characters requiring more paths to get to, while the most common characters would only have a couple. by traversing the tree until we reach each leaf and recording the path we take we can easily find an efficient encoding for each character. We store these encodings into a HashMap where the keys are the characters in the string and the values are their respective encodings. Finally, we iterate over the string and replace each character with its binary Huffman encoding. This process decreases the storage space of each character in the string from the original 8-bit code to a shorter and more space-efficient code.

To test the algorithm, the user simply needs to have the three files listed above in the same directory. Run the program and enter an integer on the keyboard when prompted by the program. If the keyboard input is not an integer format the program will detect this and propt the user again until the proper input is provided. This integer input is then used to generate a randomized string of characters. The integer inputted by the user determines the length of the string. The randomized string will then be passed into the algorithm by the test code and encoded using our Huffman encoding algorithm. As the algorithm runs, the program will print out messages to update the user with each progressive step of the algorithm. At the end, the program will have encoded the random string and will print the huffman encoding. Additionally, it will calculate and print the number of bits required to store the string both with and without huffman encoding. Here we can see that it is not uncommon for the final encoding to take up roughly 40-60% of the space that would be required to store the non-encoded string. The last step is for the program to use the character encodings that we generated to decode the randomized message and print it. This allows us to verify that the decoded string matches the original random string and that no data has been lost.        
